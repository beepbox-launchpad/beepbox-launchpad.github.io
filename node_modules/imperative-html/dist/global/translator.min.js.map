{"version":3,"sources":["../../src/translator.ts"],"names":["validJavascriptIdentifier","reservedJavascriptIdentifiers","abstract","arguments","await","boolean","break","byte","case","catch","char","class","const","continue","debugger","default","delete","do","double","else","enum","eval","export","extends","false","final","finally","float","for","function","goto","if","implements","import","in","instanceof","int","interface","let","long","native","new","null","package","private","protected","public","return","short","static","super","switch","synchronized","this","throw","throws","transient","true","try","typeof","var","void","volatile","while","with","yield","convertTextNode","node","value","nodeValue","test","replace","JSON","stringify","convertElementsRecursively","indentLevel","indentType","indentation","i","result","HTMLElement","camelCaseName","elementName","tagName","toLowerCase","c","slice","toUpperCase","SVGElement","snakeCaseName","attributes","length","attribute","specified","name_1","name","isNaN","String","parseFloat","push","hasAttributes","children","collapseChildren","childNodes","child","Text","text","Element","hasChildren","join","document","createRange","createContextualFragment","DocumentFragment"],"mappings":"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","sourcesContent":["// Copyright (C) John Nesky, distributed under the MIT license.\n\n// Simplified, but covers most cases I care about:\nconst validJavascriptIdentifier: RegExp = /^[a-z][a-zA-z0-9_]*$/;\n\nconst reservedJavascriptIdentifiers: {[key: string]: boolean} = {\"abstract\": true, \"arguments\": true, \"await\": true, \"boolean\": true, \"break\": true, \"byte\": true, \"case\": true, \"catch\": true, \"char\": true, \"class\": true, \"const\": true, \"continue\": true, \"debugger\": true, \"default\": true, \"delete\": true, \"do\": true, \"double\": true, \"else\": true, \"enum\": true, \"eval\": true, \"export\": true, \"extends\": true, \"false\": true, \"final\": true, \"finally\": true, \"float\": true, \"for\": true, \"function\": true, \"goto\": true, \"if\": true, \"implements\": true, \"import\": true, \"in\": true, \"instanceof\": true, \"int\": true, \"interface\": true, \"let\": true, \"long\": true, \"native\": true, \"new\": true, \"null\": true, \"package\": true, \"private\": true, \"protected\": true, \"public\": true, \"return\": true, \"short\": true, \"static\": true, \"super\": true, \"switch\": true, \"synchronized\": true, \"this\": true, \"throw\": true, \"throws\": true, \"transient\": true, \"true\": true, \"try\": true, \"typeof\": true, \"var\": true, \"void\": true, \"volatile\": true, \"while\": true, \"with\": true, \"yield\": true};\n\n// Converts a text node to a string, trimming away leading and trailing whitespace.\n// If the string contains tabs or newlines, wrap it in backticks, otherwise double quotes,\n// and escape the contents appropriately. \n// Returns null for nodes that are entirely whitespace.\nfunction convertTextNode(node: Node): (string | null) {\n\tlet value: string = node.nodeValue!;\n\tif (/^\\s+$/.test(value)) return null; // skip whitespace nodes.\n\tvalue = value.replace(/^(\\t|\\n|  )+/, \"\").replace(/\\s+$/, \" \");\n\tif (/[\\t\\n]/.test(value)) {\n\t\treturn \"`\" + value.replace(/`/g, \"\\\\`\").replace(/\\$\\{/g, \"\\\\${\") + \"`\";\n\t} else {\n\t\treturn JSON.stringify(value);\n\t}\n}\n\n// Recursively converts an element and all of its contents to a string of JavaScript code\n// that would generate the same element hierarchy if executed. Attempts to format the code\n// as a human might, collapsing functions with a single argument onto a single line but\n// spreading more complex arguments across multiple indented lines using the provided\n// indentType string.\nfunction convertElementsRecursively(node: Element, indentLevel: number, indentType: string): string {\n\tlet indentation = \"\"; // indentType.repeat(indentLevel) doesn't work in Internet Explorer...\n\tfor (let i: number = 0; i < indentLevel; i++) indentation += indentType;\n\t\n\tlet result: string = indentation;\n\tif (node instanceof HTMLElement) {\n\t\tresult += \"HTML\";\n\t\tconst elementName: string = node.tagName.toLowerCase();\n\t\tconst camelCaseName: string = elementName.replace(/-[a-z]/, (c) => c.slice(1).toUpperCase()).replace(/-/g, \"_\");\n\t\tconst validIdentifier: boolean = validJavascriptIdentifier.test(camelCaseName) && !reservedJavascriptIdentifiers[camelCaseName];\n\t\tresult += validIdentifier ? (\".\" + camelCaseName) : (\"[\" + JSON.stringify(elementName) + \"]\");\n\t} else if (node instanceof SVGElement) {\n\t\tresult += \"SVG\";\n\t\tconst elementName: string = node.tagName;\n\t\tconst snakeCaseName: string = elementName.replace(/-/g, \"_\");\n\t\tconst validIdentifier: boolean = validJavascriptIdentifier.test(snakeCaseName) && !reservedJavascriptIdentifiers[snakeCaseName];\n\t\tresult += validIdentifier ? (\".\" + snakeCaseName) : (\"[\" + JSON.stringify(elementName) + \"]\");\n\t} else {\n\t\treturn indentation + \"<Unrecognized node type>,\\n\";\n\t}\n\t\n\tconst attributes: string[] = [];\n\tif (node.attributes.length > 0) {\n\t\t//for (const attribute of node.attributes) { // not backwards compatible with Internet Explorer.\n\t\tfor (let i: number = 0; i < node.attributes.length; i++) { const attribute = node.attributes[i];\n\t\t\tif (!attribute.specified) continue;\n\t\t\tlet name: string = attribute.name;\n\t\t\tif (!validJavascriptIdentifier.test(name)) name = JSON.stringify(name);\n\t\t\tlet value: string = attribute.value;\n\t\t\tif (value === \"\") {\n\t\t\t\tvalue = \"true\";\n\t\t\t} else if (isNaN(<any>value) || String(parseFloat(value)) !== value) {\n\t\t\t\tvalue = JSON.stringify(value);\n\t\t\t}\n\t\t\tattributes.push(name + \": \" + value);\n\t\t}\n\t}\n\tconst hasAttributes: boolean = attributes.length > 0;\n\t\n\tconst children: string[] = [];\n\tlet collapseChildren: boolean = false;\n\t//for (const child of node.childNodes) { // not backwards compatible with Internet Explorer.\n\tfor (let i: number = 0; i < node.childNodes.length; i++) { const child = node.childNodes[i];\n\t\tif (child instanceof Text) {\n\t\t\tconst text = convertTextNode(child);\n\t\t\tif (text != null) {\n\t\t\t\tif (!hasAttributes && node.childNodes.length === 1 && !/[\\n]/.test(text)) {\n\t\t\t\t\tchildren.push(text);\n\t\t\t\t\t// Don't add whitespace around single text node child:\n\t\t\t\t\tcollapseChildren = true;\n\t\t\t\t} else {\n\t\t\t\t\t// Put text node on its own indented line followed by a comma.\n\t\t\t\t\tchildren.push(indentation + indentType + text + \",\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (child instanceof Element) {\n\t\t\tchildren.push(convertElementsRecursively(child, indentLevel + 1, indentType));\n\t\t}\n\t}\n\tconst hasChildren: boolean = children.length > 0;\n\t\n\tresult += \"(\";\n\tif (hasAttributes) {\n\t\tresult += \"{\" + attributes.join(\", \") + \"}\";\n\t\tif (hasChildren) result += \",\";\n\t}\n\tif (collapseChildren) {\n\t\tresult += children.join(\"\");\n\t} else if (hasChildren) {\n\t\tresult += \"\\n\" + children.join(\"\") + indentation;\n\t}\n\tresult += \")\";\n\treturn result + \",\\n\";\n}\n\n/**\n * Converts an element and all of its contents to a string of JavaScript code that would\n * generate the same element hierarchy if executed using the imperative-html library,\n * attempting to format the code as a human might. The first argument can be an instantiated\n * element or a string of HTML code. There is an optional second argument to set the indentation\n * type; it defaults to a tab character but you may wish to set it to spaces. \n */\nexport function translateElementsToImperativeCode(node: Node, indentType: string = \"\\t\"): string {\n\tif (typeof node === \"string\") node = document.createRange().createContextualFragment(node);\n\tlet result = \"\";\n\tif (node instanceof DocumentFragment) {\n\t\t//for (const child of node.childNodes) { // not backwards compatible with Internet Explorer.\n\t\tfor (let i: number = 0; i < node.childNodes.length; i++) { const child = node.childNodes[i];\n\t\t\tif (child instanceof Text) {\n\t\t\t\tconst text = convertTextNode(child);\n\t\t\t\tif (text != null) result += text + \",\\n\";\n\t\t\t} else if (child instanceof Element) {\n\t\t\t\tresult += convertElementsRecursively(child, 0, indentType);\n\t\t\t}\n\t\t}\n\t} else if (node instanceof Text) {\n\t\tconst text = convertTextNode(node);\n\t\tif (text != null) result += text + \",\\n\";\n\t} else if (node instanceof Element) {\n\t\tresult += convertElementsRecursively(node, 0, indentType);\n\t}\n\treturn result.replace(/,\\n$/, \"\");\n}\n"]}