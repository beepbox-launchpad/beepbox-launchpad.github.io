var validJavascriptIdentifier = /^[a-z][a-zA-z0-9_]*$/;
var reservedJavascriptIdentifiers = { "abstract": true, "arguments": true, "await": true, "boolean": true, "break": true, "byte": true, "case": true, "catch": true, "char": true, "class": true, "const": true, "continue": true, "debugger": true, "default": true, "delete": true, "do": true, "double": true, "else": true, "enum": true, "eval": true, "export": true, "extends": true, "false": true, "final": true, "finally": true, "float": true, "for": true, "function": true, "goto": true, "if": true, "implements": true, "import": true, "in": true, "instanceof": true, "int": true, "interface": true, "let": true, "long": true, "native": true, "new": true, "null": true, "package": true, "private": true, "protected": true, "public": true, "return": true, "short": true, "static": true, "super": true, "switch": true, "synchronized": true, "this": true, "throw": true, "throws": true, "transient": true, "true": true, "try": true, "typeof": true, "var": true, "void": true, "volatile": true, "while": true, "with": true, "yield": true };
function convertTextNode(node) {
    var value = node.nodeValue;
    if (/^\s+$/.test(value))
        return null;
    value = value.replace(/^(\t|\n|  )+/, "").replace(/\s+$/, " ");
    if (/[\t\n]/.test(value)) {
        return "`" + value.replace(/`/g, "\\`").replace(/\$\{/g, "\\${") + "`";
    }
    else {
        return JSON.stringify(value);
    }
}
function convertElementsRecursively(node, indentLevel, indentType) {
    var indentation = "";
    for (var i = 0; i < indentLevel; i++)
        indentation += indentType;
    var result = indentation;
    if (node instanceof HTMLElement) {
        result += "HTML";
        var elementName = node.tagName.toLowerCase();
        var camelCaseName = elementName.replace(/-[a-z]/, function (c) { return c.slice(1).toUpperCase(); }).replace(/-/g, "_");
        var validIdentifier = validJavascriptIdentifier.test(camelCaseName) && !reservedJavascriptIdentifiers[camelCaseName];
        result += validIdentifier ? ("." + camelCaseName) : ("[" + JSON.stringify(elementName) + "]");
    }
    else if (node instanceof SVGElement) {
        result += "SVG";
        var elementName = node.tagName;
        var snakeCaseName = elementName.replace(/-/g, "_");
        var validIdentifier = validJavascriptIdentifier.test(snakeCaseName) && !reservedJavascriptIdentifiers[snakeCaseName];
        result += validIdentifier ? ("." + snakeCaseName) : ("[" + JSON.stringify(elementName) + "]");
    }
    else {
        return indentation + "<Unrecognized node type>,\n";
    }
    var attributes = [];
    if (node.attributes.length > 0) {
        for (var i = 0; i < node.attributes.length; i++) {
            var attribute = node.attributes[i];
            if (!attribute.specified)
                continue;
            var name_1 = attribute.name;
            if (!validJavascriptIdentifier.test(name_1))
                name_1 = JSON.stringify(name_1);
            var value = attribute.value;
            if (value === "") {
                value = "true";
            }
            else if (isNaN(value) || String(parseFloat(value)) !== value) {
                value = JSON.stringify(value);
            }
            attributes.push(name_1 + ": " + value);
        }
    }
    var hasAttributes = attributes.length > 0;
    var children = [];
    var collapseChildren = false;
    for (var i = 0; i < node.childNodes.length; i++) {
        var child = node.childNodes[i];
        if (child instanceof Text) {
            var text = convertTextNode(child);
            if (text != null) {
                if (!hasAttributes && node.childNodes.length === 1 && !/[\n]/.test(text)) {
                    children.push(text);
                    collapseChildren = true;
                }
                else {
                    children.push(indentation + indentType + text + ",\n");
                }
            }
        }
        else if (child instanceof Element) {
            children.push(convertElementsRecursively(child, indentLevel + 1, indentType));
        }
    }
    var hasChildren = children.length > 0;
    result += "(";
    if (hasAttributes) {
        result += "{" + attributes.join(", ") + "}";
        if (hasChildren)
            result += ",";
    }
    if (collapseChildren) {
        result += children.join("");
    }
    else if (hasChildren) {
        result += "\n" + children.join("") + indentation;
    }
    result += ")";
    return result + ",\n";
}
export function translateElementsToImperativeCode(node, indentType) {
    if (indentType === void 0) { indentType = "\t"; }
    if (typeof node === "string")
        node = document.createRange().createContextualFragment(node);
    var result = "";
    if (node instanceof DocumentFragment) {
        for (var i = 0; i < node.childNodes.length; i++) {
            var child = node.childNodes[i];
            if (child instanceof Text) {
                var text = convertTextNode(child);
                if (text != null)
                    result += text + ",\n";
            }
            else if (child instanceof Element) {
                result += convertElementsRecursively(child, 0, indentType);
            }
        }
    }
    else if (node instanceof Text) {
        var text = convertTextNode(node);
        if (text != null)
            result += text + ",\n";
    }
    else if (node instanceof Element) {
        result += convertElementsRecursively(node, 0, indentType);
    }
    return result.replace(/,\n$/, "");
}
//# sourceMappingURL=translator.js.map